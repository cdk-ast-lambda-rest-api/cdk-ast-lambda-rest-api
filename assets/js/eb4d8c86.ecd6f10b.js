"use strict";(self.webpackChunkcalra_docs=self.webpackChunkcalra_docs||[]).push([[5111],{4800:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var r=n(4848),t=n(8453);const s={sidebar_label:"Decorators",sidebar_position:2,description:"Setup your Lambda Function options using decorators."},a="Lambda Decorators",i={id:"lambda/decorators",title:"Lambda Decorators",description:"Setup your Lambda Function options using decorators.",source:"@site/docs/lambda/decorators.md",sourceDirName:"lambda",slug:"/lambda/decorators",permalink:"/docs/lambda/decorators",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/lambda/decorators.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_label:"Decorators",sidebar_position:2,description:"Setup your Lambda Function options using decorators."},sidebar:"docsSidebar",previous:{title:"About",permalink:"/docs/lambda/about"},next:{title:"Docusaurus",permalink:"/docs/category/docusaurus"}},d={},c=[{value:"HTTP Decorators",id:"http-decorators",level:2},{value:"Custom Decorators",id:"custom-decorators",level:2},{value:"Naming Decorators",id:"naming-decorators",level:3},{value:"Configuration Decorators",id:"configuration-decorators",level:3}];function l(e){const o={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(o.h1,{id:"lambda-decorators",children:"Lambda Decorators"}),"\n",(0,r.jsxs)(o.p,{children:["As previously mentioned, a developer relies on calra's cdk package to add custom options that can be applied to his Lambda Functions. But how do we associate these custom values to a specific Lambda? By the use of the decorators comprehended in calra's lambda package.\nThere are two types of decorators defined for this module. ",(0,r.jsx)(o.strong,{children:"HTTP Decorators"})," first and ",(0,r.jsx)(o.strong,{children:"Custom Decorators"})," on the other hand."]}),"\n",(0,r.jsx)(o.h2,{id:"http-decorators",children:"HTTP Decorators"}),"\n",(0,r.jsxs)(o.p,{children:["For a Lambda Function to be recognised during the building process, so the resource is created and connected to the API Gateway, an HTTP decorator is required. This decorators sets both the HTTP method and the endpoint's route. HTTP methods supported by Calra are ",(0,r.jsx)(o.strong,{children:"GET, POST, PUT, DELETE and ANY"}),". Let's have a quick look to an example."]}),"\n",(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{className:"language-python",children:"    from calra_lambda import *\n    import json\n\n    @GET('/dogs')\n    def lambda_handler(event, context):\n        response = {\n            'statusCode': 200,\n            'body': json.dumps({\n                'message': 'Hello World from /dogs!'\n            })\n        }\n        return response\n"})}),"\n",(0,r.jsx)(o.p,{children:"By simply importing the module and adding just one decorator a developer can rest easy and not worry about defining the infrastructure for a simple Lambda Function, let alone multiple."}),"\n",(0,r.jsx)(o.admonition,{type:"warning",children:(0,r.jsxs)(o.p,{children:["At this time, you should specify the decorators as shown in the example. Do not apply other invoking methods such as ",(0,r.jsx)(o.code,{children:"calra_lambda.GET()"}),"."]})}),"\n",(0,r.jsx)(o.h2,{id:"custom-decorators",children:"Custom Decorators"}),"\n",(0,r.jsx)(o.p,{children:"Diving into advanced applications of Calra, the possibility of setting custom parameters for a Lambda Function during build time was talked about. On this topic there are also two types of decorators, one for configuration and the other for naming purposes."}),"\n",(0,r.jsx)(o.h3,{id:"naming-decorators",children:"Naming Decorators"}),"\n",(0,r.jsxs)(o.p,{children:["Two decorators are defined for this and allows the user to name the resource and set it's description. So, logically, they are called ",(0,r.jsx)(o.strong,{children:(0,r.jsx)(o.code,{children:"name"})})," and ",(0,r.jsx)(o.strong,{children:(0,r.jsx)(o.code,{children:"description"})}),"."]}),"\n",(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{className:"language-python",children:"from calra_lambda import *\nimport json\n\n    @GET('/dogs')\n    @name('LBD-DOGS-GET')\n    @description('Basic lambda handler for dogs GET route.')\n    def lambda_handler(event, context):\n        response = {\n            'statusCode': 200,\n            'body': json.dumps({\n                'message': 'Hello World from /dogs!'\n            })\n        }\n        return response\n"})}),"\n",(0,r.jsx)(o.h3,{id:"configuration-decorators",children:"Configuration Decorators"}),"\n",(0,r.jsxs)(o.p,{children:[(0,r.jsx)(o.strong,{children:(0,r.jsx)(o.code,{children:"timeout"})})," and ",(0,r.jsx)(o.strong,{children:(0,r.jsx)(o.code,{children:"memory_size"})})," can be assigned without defining custom key-values for them during the builder definition. Instead, timeout is automatically converted to Duration.Seconds whilst memory_size is the amount of memory, in MB, that will be allocated to the Lambda Function during runtime."]}),"\n",(0,r.jsxs)(o.p,{children:[(0,r.jsx)(o.strong,{children:(0,r.jsx)(o.code,{children:"security_group"})}),", ",(0,r.jsx)(o.strong,{children:(0,r.jsx)(o.code,{children:"layer"})}),", and ",(0,r.jsx)(o.strong,{children:(0,r.jsx)(o.code,{children:"environment"})})," decorators support both a list of string keys as a parameter or multiple string parameters. This is because a Lambda Function support multiple security_groups, layer and environments assigned to it. Keep in mind the string parameters have to match the ",(0,r.jsx)(o.strong,{children:"key"})," of custom settings defined for your builder instance, so Calra can use them to retrieve the ",(0,r.jsx)(o.strong,{children:"value"}),"."]}),"\n",(0,r.jsxs)(o.p,{children:[(0,r.jsx)(o.strong,{children:(0,r.jsx)(o.code,{children:"vpc"})}),", ",(0,r.jsx)(o.strong,{children:(0,r.jsx)(o.code,{children:"role"})})," and ",(0,r.jsx)(o.strong,{children:(0,r.jsx)(o.code,{children:"runtime"})})," decorators, on the other hand only accept a string parameter that should match the ",(0,r.jsx)(o.strong,{children:"key"})," of a custom configuration defined for yor builder, so Calra can use that to retrieve the ",(0,r.jsx)(o.strong,{children:"value"})," and assign it to your lambda function."]}),"\n",(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{className:"language-python",children:"from calra_lambda import *\nimport json\nimport os\nimport django\nimport pydantic\n\n@DELETE('/cats/delete/{id}')\n@role('lambda-rds-role')\n@environment('DB_NAME_CATS','DB_HOST')\n@layer(['djangoLayer','pydanticLayer'])\n@memory_size(256)\ndef cat_handler(event, context):\n    response = {\n        'statusCode': 200,\n        'body': json.dumps({\n            'message': f\"Hello from /cats! Connecting to.. {os.environ['DB_NAME_CATS']}\"\n        })\n    }\n    return response\n"})}),"\n",(0,r.jsx)(o.admonition,{type:"danger",children:(0,r.jsxs)(o.p,{children:["You should never add the same ",(0,r.jsx)(o.strong,{children:"configuration decorator"})," twice to a Lambda Handler twice. For options that can receive multiple arguments, such as security_group, layer and environment, use the multiple arguments or list as a parameter for a single decorator."]})})]})}function u(e={}){const{wrapper:o}={...(0,t.R)(),...e.components};return o?(0,r.jsx)(o,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>a,x:()=>i});var r=n(6540);const t={},s=r.createContext(t);function a(e){const o=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function i(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(s.Provider,{value:o},e.children)}}}]);